
Here is an improved and more robust version of your Spanner integration with Kotlin using the latest industry standards. This version enhances readability, maintainability, and security while adhering to best practices such as clean architecture principles, dependency injection, better error handling, and environment-specific configurations.

1. Add Dependencies to build.gradle.kts
First, make sure you include the necessary dependencies for Google Cloud Spanner, Kotlin coroutines, and Spring Boot in your build.gradle.kts.


dependencies {
    implementation("com.google.cloud:google-cloud-spanner:6.23.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4")
    implementation("com.google.cloud:spring-cloud-gcp-starter-data-spanner")
    implementation("org.springframework.boot:spring-boot-starter-data-rest")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("org.slf4j:slf4j-api:1.7.36")
}
2. Environment-Specific Configuration: application.yml
Define properties for different environments like dev, test, and prod using profiles. This enables your application to automatically load the right configuration depending on the environment.

application.yml:


spring:
  profiles:
    active: dev
application-dev.yml:


spanner:
  project-id: dev-project-id
  instance-id: dev-instance-id
  database-id: dev-database-id
  feature-flag:
    enable-spanner-integration: true
application-prod.yml:


spanner:
  project-id: prod-project-id
  instance-id: prod-instance-id
  database-id: prod-database-id
  feature-flag:
    enable-spanner-integration: true
By setting up configuration for each environment, you improve flexibility and scalability for future updates.

3. Spanner Configuration and Feature Flag Support
Create a configuration class to handle the integration and feature flag logic. This class centralizes configuration, ensuring consistency across environments.

SpannerProperties.kt:


import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Configuration
import javax.validation.constraints.NotBlank

@Configuration
@EnableConfigurationProperties
@ConfigurationProperties(prefix = "spanner")
data class SpannerProperties(
    @field:NotBlank val projectId: String,
    @field:NotBlank val instanceId: String,
    @field:NotBlank val databaseId: String,
    val featureFlag: FeatureFlag
)

data class FeatureFlag(
    val enableSpannerIntegration: Boolean
)
SpannerConfig.kt:

kotlin
Copy code
import com.google.cloud.spanner.DatabaseId
import com.google.cloud.spanner.Spanner
import com.google.cloud.spanner.SpannerOptions
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SpannerConfig(private val properties: SpannerProperties) {

    @Bean
    fun spanner(): Spanner = SpannerOptions.newBuilder()
        .setProjectId(properties.projectId)
        .build()
        .service

    @Bean
    fun databaseId(): DatabaseId = DatabaseId.of(
        properties.projectId,
        properties.instanceId,
        properties.databaseId
    )
}
Improvements:
@ConfigurationProperties: Separates concerns by externalizing configuration values.
Feature Flag: Controlled through external properties to enable/disable features dynamically.
4. Data Model Class with Google Cloud Timestamp
Use proper annotations to define the Spanner data model. In this version, we use Google Cloud Timestamp instead of Java’s Instant.

UserAction.kt:


import com.google.cloud.Timestamp
import org.springframework.data.annotation.Id
import org.springframework.data.spanner.core.mapping.Table
import org.springframework.data.spanner.core.mapping.Column
import javax.validation.constraints.NotBlank

@Table(name = "UserActions")
data class UserAction(
    @Id
    @Column(name = "actionId")
    @field:NotBlank val actionId: String,

    @Column(name = "userId")
    val userId: String?,

    @Column(name = "sessionId")
    val sessionId: String?,

    @Column(name = "traceId")
    val traceId: String?,

    @Column(name = "globalAddressId")
    val globalAddressId: String?,

    @Column(name = "ipAddress")
    val ipAddress: String?,

    @Column(name = "timestamp")
    val timestamp: Timestamp,  // Google Cloud Timestamp with commit support

    @Column(name = "actionType")
    @field:NotBlank val actionType: String,

    @Column(name = "currentStep")
    val currentStep: String?,

    @Column(name = "selectionData")
    val selectionData: Map<String, Any>?,

    @Column(name = "userAgent")
    val userAgent: String?,

    @Column(name = "errorCode")
    val errorCode: String?,

    @Column(name = "errorMessage")
    val errorMessage: String?
)
Improvements:
Google Cloud Timestamp: Provides consistency across operations and supports COMMIT_TIMESTAMP.
@NotBlank Annotations: Ensure critical fields like actionId and actionType are never null.
5. Spanner Repository Interface
Use the SpannerRepository interface provided by Spring Data to manage UserAction data in Spanner. This eliminates the need for manual CRUD operation logic.

UserActionRepository.kt:


import com.google.cloud.spring.data.spanner.repository.SpannerRepository
import org.springframework.stereotype.Repository

@Repository
interface UserActionRepository : SpannerRepository<UserAction, String>
Improvements:
Automatic Repository Methods: Reduces boilerplate by using Spring Data’s repository mechanism.
Cleaner Code: Spring Data abstracts common database interactions.
6. Service Layer with Feature Flag Check
Implement the service layer to handle the business logic. The service layer checks whether the Spanner integration is enabled using the feature flag before interacting with the repository.

UserActionService.kt:


import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import kotlin.coroutines.CoroutineContext

@Service
class UserActionService(
    private val repository: UserActionRepository,
    private val properties: SpannerProperties,
    private val coroutineContext: CoroutineContext = Dispatchers.Default
) {
    private val logger = LoggerFactory.getLogger(UserActionService::class.java)

    suspend fun processAction(actionDetails: ActionDetails) = withContext(coroutineContext) {
        if (properties.featureFlag.enableSpannerIntegration) {
            val action = buildUserAction(actionDetails)
            try {
                repository.save(action)
                logger.info("Successfully saved action: actionId=${action.actionId}, userId=${action.userId}, traceId=${action.traceId}")
            } catch (e: Exception) {
                logger.error("Failed to save action: actionId=${action.actionId}, userId=${action.userId}, traceId=${action.traceId}", e)
                throw e
            }
        } else {
            logger.info("Spanner integration is disabled in this environment.")
        }
    }

    suspend fun getAction(actionId: String): UserAction? = withContext(coroutineContext) {
        if (properties.featureFlag.enableSpannerIntegration) {
            repository.findById(actionId).orElse(null)
        } else {
            logger.info("Spanner integration is disabled in this environment.")
            null
        }
    }

    private fun buildUserAction(actionDetails: ActionDetails): UserAction {
        return UserAction(
            actionId = generateActionId(),
            userId = actionDetails.userId,
            sessionId = actionDetails.sessionId,
            traceId = actionDetails.traceId,
            globalAddressId = actionDetails.globalAddressId,
            ipAddress = actionDetails.ipAddress,
            timestamp = Timestamp.now(),  // Use Spanner commit timestamp if needed
            actionType = actionDetails.actionType,
            currentStep = actionDetails.currentStep,
            selectionData = actionDetails.selectionData,
            userAgent = actionDetails.userAgent,
            errorCode = actionDetails.errorCode,
            errorMessage = actionDetails.errorMessage
        )
    }

    private fun generateActionId(): String {
        return "generated-unique-action-id"  // Logic to generate a unique actionId, e.g., UUID
    }
}

    
Improvements:
Feature Flag Logic: The service respects the feature flag to enable/disable integration.
Exception Handling: Catches and logs exceptions to prevent silent failures.
Kotlin Coroutines: Ensures non-blocking I/O using withContext(Dispatchers.IO).
7. Run the Application with Feature Flags
You can run the application using different profiles for dev, test, or prod environments. The correct feature flag will be loaded based on the active profile.
