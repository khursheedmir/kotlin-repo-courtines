import com.google.cloud.Timestamp
import com.google.cloud.spring.data.spanner.core.mapping.Column
import com.google.cloud.spring.data.spanner.core.mapping.PrimaryKey
import com.google.cloud.spring.data.spanner.core.mapping.Table
import javax.validation.constraints.NotBlank

@Table(name = "UserActions")  // Maps to the "UserActions" table in Spanner
data class UserAction(
    @PrimaryKey
    @Column(name = "actionId")  // Marks actionId as the primary key
    @field:NotBlank val actionId: String,  // Ensure actionId is not blank

    @Column(name = "userId")
    val userId: String?,  // Can be nullable for anonymous actions

    @Column(name = "sessionId")
    val sessionId: String?,  // Optional sessionId

    @Column(name = "traceId")
    val traceId: String?,  // TraceId for tracking requests

    @Column(name = "globalAddressId")
    val globalAddressId: String?,  // Address associated with the action

    @Column(name = "ipAddress")
    val ipAddress: String?,  // IP address for pre-login tracking

    @Column(name = "timestamp")  // Using Google Cloud Timestamp for commit timestamp support
    val timestamp: Timestamp,

    @Column(name = "actionType")
    @field:NotBlank val actionType: String,  // Action type should not be blank

    @Column(name = "currentStep")
    val currentStep: String?,  // The current step in the user journey

    @Column(name = "selectionData", spannerType = "JSON")  // Using JSON type for structured data
    val selectionData: Map<String, Any>?,

    @Column(name = "userAgent")
    val userAgent: String?,  // Device/browser information

    @Column(name = "errorCode")
    val errorCode: String?,  // Error code in case of a failure

    @Column(name = "errorMessage")
    val errorMessage: String?  // Error message for further details
)
================================================================================

      import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import kotlin.coroutines.CoroutineContext

@Service
class UserActionService(
    private val repository: UserActionRepository,
    private val coroutineContext: CoroutineContext = Dispatchers.Default
) {
    private val logger = LoggerFactory.getLogger(UserActionService::class.java)

    // This function processes the action and builds the UserAction object centrally
    suspend fun processAction(actionDetails: ActionDetails) = coroutineScope {
        val action = buildUserAction(actionDetails)
        try {
            repository.save(action)
            logger.info("Successfully saved action: actionId=${action.actionId}, userId=${action.userId}, traceId=${action.traceId}")
        } catch (e: Exception) {
            logger.error("Failed to save action: actionId=${action.actionId}, userId=${action.userId}, traceId=${action.traceId}", e)
            throw e
        }
    }

    // This function retrieves the action from the repository
    suspend fun getAction(actionId: String): UserAction? = coroutineScope {
        try {
            repository.findByActionId(actionId)
        } catch (e: Exception) {
            logger.error("Failed to retrieve action: actionId=$actionId", e)
            throw e
        }
    }

    // Helper function to build UserAction object from provided details
    private fun buildUserAction(actionDetails: ActionDetails): UserAction {
        return UserAction(
            actionId = generateActionId(),
            userId = actionDetails.userId,
            sessionId = actionDetails.sessionId,
            traceId = actionDetails.traceId,
            globalAddressId = actionDetails.globalAddressId,
            ipAddress = actionDetails.ipAddress,
            timestamp = actionDetails.timestamp,
            actionType = actionDetails.actionType,
            currentStep = actionDetails.currentStep,
            selectionData = actionDetails.selectionData,
            userAgent = actionDetails.userAgent,
            errorCode = actionDetails.errorCode,
            errorMessage = actionDetails.errorMessage
        )
    }

    // You can include logic here to generate the actionId
    private fun generateActionId(): String {
        // Logic for generating a unique actionId, e.g., UUID
        return "generated-unique-action-id"
    }
}

// Define ActionDetails as a data class that contains the parameters needed to build the UserAction object
data class ActionDetails(
    val userId: String?,
    val sessionId: String?,
    val traceId: String?,
    val globalAddressId: String?,
    val ipAddress: String?,
    val timestamp: Instant,
    val actionType: String,
    val currentStep: String?,
    val selectionData: Map<String, Any>?,
    val userAgent: String?,
    val errorCode: String?,
    val errorMessage: String?
)
